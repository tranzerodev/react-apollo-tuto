{"ast":null,"code":"import { __assign } from 'tslib';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { getFragmentFromSelection } from '../../utilities/graphql/fragments.js';\nimport { getTypenameFromResult, argumentsObjectFromField, storeKeyNameFromField, getStoreKeyName, isReference, isField } from '../../utilities/graphql/storeUtils.js';\nimport { canUseWeakMap } from '../../utilities/common/canUse.js';\nimport { KeyTrie } from 'optimism';\nimport { fieldNameFromStoreName, storeValueIsStoreObject, isFieldValueToBeMerged, hasOwn } from './helpers.js';\n\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nvar defaultDataIdFromObject = function (_a, context) {\n  var __typename = _a.__typename,\n      id = _a.id,\n      _id = _a._id;\n\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = id !== void 0 ? {\n        id: id\n      } : _id !== void 0 ? {\n        _id: _id\n      } : void 0;\n    }\n\n    var idValue = id || _id;\n\n    if (idValue !== void 0) {\n      return __typename + \":\" + (typeof idValue === \"number\" || typeof idValue === \"string\" ? idValue : JSON.stringify(idValue));\n    }\n  }\n};\n\nvar nullKeyFieldsFn = function () {\n  return void 0;\n};\n\nvar simpleKeyArgsFn = function (_args, context) {\n  return context.fieldName;\n};\n\nvar Policies = function () {\n  function Policies(config) {\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.storageTrie = new KeyTrie(true);\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n    var typename = selectionSet && fragmentMap ? getTypenameFromResult(object, selectionSet, fragmentMap) : object.__typename;\n    var context = {\n      typename: typename,\n      selectionSet: selectionSet,\n      fragmentMap: fragmentMap\n    };\n    var id;\n    var policy = this.getTypePolicy(typename, false);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n\n    while (keyFn) {\n      var specifierOrId = keyFn(object, context);\n\n      if (Array.isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id && String(id);\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n\n    Object.keys(typePolicies).forEach(function (typename) {\n      var existing = _this.getTypePolicy(typename, true);\n\n      var incoming = typePolicies[typename];\n      var keyFields = incoming.keyFields,\n          fields = incoming.fields;\n      if (incoming.queryType) _this.setRootTypename(\"Query\", typename);\n      if (incoming.mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (incoming.subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n      existing.keyFn = keyFields === false ? nullKeyFieldsFn : Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === \"function\" ? keyFields : existing.keyFn;\n\n      if (fields) {\n        Object.keys(fields).forEach(function (fieldName) {\n          var existing = _this.getFieldPolicy(typename, fieldName, true);\n\n          var incoming = fields[fieldName];\n\n          if (typeof incoming === \"function\") {\n            existing.read = incoming;\n          } else {\n            var keyArgs = incoming.keyArgs,\n                read = incoming.read,\n                merge = incoming.merge;\n            existing.keyFn = keyArgs === false ? simpleKeyArgsFn : Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing.keyFn;\n            if (typeof read === \"function\") existing.read = read;\n            if (typeof merge === \"function\") existing.merge = merge;\n          }\n\n          if (existing.read && existing.merge) {\n            existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n          }\n        });\n      }\n    });\n  };\n\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n\n    if (typename !== old) {\n      process.env.NODE_ENV === \"production\" ? invariant(!old || old === which, 34) : invariant(!old || old === which, \"Cannot change root \" + which + \" __typename more than once\");\n      this.rootIdsByTypename[typename] = rootId;\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      var subtypeSet = _this.getSubtypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);\n    });\n  };\n\n  Policies.prototype.getTypePolicy = function (typename, createIfMissing) {\n    if (typename) {\n      return this.typePolicies[typename] || createIfMissing && (this.typePolicies[typename] = Object.create(null));\n    }\n  };\n\n  Policies.prototype.getSubtypeSet = function (supertype, createIfMissing) {\n    var policy = this.getTypePolicy(supertype, createIfMissing);\n\n    if (policy) {\n      return policy.subtypes || (createIfMissing ? policy.subtypes = new Set() : void 0);\n    }\n  };\n\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    var typePolicy = this.getTypePolicy(typename, createIfMissing);\n\n    if (typePolicy) {\n      var fieldPolicies = typePolicy.fields || createIfMissing && (typePolicy.fields = Object.create(null));\n\n      if (fieldPolicies) {\n        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n      }\n    }\n  };\n\n  Policies.prototype.fragmentMatches = function (fragment, typename) {\n    var _this = this;\n\n    if (!fragment.typeCondition) return true;\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes) {\n      var workQueue_1 = [this.getSubtypeSet(supertype, false)];\n\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var subtypes = workQueue_1[i];\n\n        if (subtypes) {\n          if (subtypes.has(typename)) return true;\n          subtypes.forEach(function (subtype) {\n            var subsubtypes = _this.getSubtypeSet(subtype, false);\n\n            if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {\n              workQueue_1.push(subsubtypes);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Policies.prototype.getStoreFieldName = function (fieldSpec) {\n    var typename = fieldSpec.typename,\n        fieldName = fieldSpec.fieldName;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n\n    if (keyFn && typename) {\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: fieldSpec.field || null\n      };\n      var args = argsFromFieldSpecifier(fieldSpec);\n\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n\n        if (Array.isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n\n  Policies.prototype.readField = function (options, context) {\n    var objectOrReference = options.from;\n    if (!objectOrReference) return;\n    var nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      var typename = context.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    var storeFieldName = this.getStoreFieldName(options);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.getFieldValue(objectOrReference, storeFieldName);\n    var policy = this.getFieldPolicy(options.typename, fieldName, false);\n    var read = policy && policy.read;\n\n    if (read) {\n      var storage = this.storageTrie.lookup(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName);\n      return read(existing, makeFieldFunctionOptions(this, objectOrReference, options, storage, context));\n    }\n\n    return existing;\n  };\n\n  Policies.prototype.hasMergeFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.merge);\n  };\n\n  Policies.prototype.applyMerges = function (existing, incoming, context, storageKeys) {\n    var _this = this;\n\n    if (isFieldValueToBeMerged(incoming)) {\n      var field = incoming.__field;\n      var fieldName = field.name.value;\n      var merge = this.getFieldPolicy(incoming.__typename, fieldName, false).merge;\n      var storage = storageKeys ? this.storageTrie.lookupArray(storageKeys) : null;\n      incoming = merge(existing, incoming.__value, makeFieldFunctionOptions(this, void 0, {\n        typename: incoming.__typename,\n        fieldName: fieldName,\n        field: field,\n        variables: context.variables\n      }, storage, context));\n    }\n\n    if (Array.isArray(incoming)) {\n      return incoming.map(function (item) {\n        return _this.applyMerges(void 0, item, context);\n      });\n    }\n\n    if (storeValueIsStoreObject(incoming)) {\n      var e_1 = existing;\n      var i_1 = incoming;\n      var firstStorageKey_1 = isReference(e_1) ? e_1.__ref : typeof e_1 === \"object\" && e_1;\n      var newFields_1;\n      Object.keys(i_1).forEach(function (storeFieldName) {\n        var incomingValue = i_1[storeFieldName];\n\n        var appliedValue = _this.applyMerges(context.getFieldValue(e_1, storeFieldName), incomingValue, context, firstStorageKey_1 ? [firstStorageKey_1, storeFieldName] : void 0);\n\n        if (appliedValue !== incomingValue) {\n          newFields_1 = newFields_1 || Object.create(null);\n          newFields_1[storeFieldName] = appliedValue;\n        }\n      });\n\n      if (newFields_1) {\n        return __assign(__assign({}, i_1), newFields_1);\n      }\n    }\n\n    return incoming;\n  };\n\n  return Policies;\n}();\n\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, storage, context) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    isReference: isReference,\n    toReference: context.toReference,\n    storage: storage,\n    cache: policies.cache,\n    canRead: context.canRead,\n    readField: function (fieldNameOrOptions, from) {\n      var options = typeof fieldNameOrOptions === \"string\" ? {\n        fieldName: fieldNameOrOptions,\n        from: from\n      } : __assign({}, fieldNameOrOptions);\n\n      if (void 0 === options.from) {\n        options.from = objectOrReference;\n      }\n\n      if (void 0 === options.variables) {\n        options.variables = variables;\n      }\n\n      return policies.readField(options, context);\n    },\n    mergeObjects: function (existing, incoming) {\n      if (Array.isArray(existing) || Array.isArray(incoming)) {\n        throw process.env.NODE_ENV === \"production\" ? new InvariantError(35) : new InvariantError(\"Cannot automatically merge arrays\");\n      }\n\n      if (existing && typeof existing === \"object\" && incoming && typeof incoming === \"object\") {\n        var eType = context.getFieldValue(existing, \"__typename\");\n        var iType = context.getFieldValue(incoming, \"__typename\");\n        var typesDiffer = eType && iType && eType !== iType;\n        var applied = policies.applyMerges(typesDiffer ? void 0 : existing, incoming, context);\n\n        if (typesDiffer || !storeValueIsStoreObject(existing) || !storeValueIsStoreObject(applied)) {\n          return applied;\n        }\n\n        return __assign(__assign({}, existing), applied);\n      }\n\n      return incoming;\n    }\n  };\n}\n\nfunction keyArgsFnFromSpecifier(specifier) {\n  return function (args, context) {\n    return args ? context.fieldName + \":\" + JSON.stringify(computeKeyObject(args, specifier)) : context.fieldName;\n  };\n}\n\nfunction keyFieldsFnFromSpecifier(specifier) {\n  var trie = new KeyTrie(canUseWeakMap);\n  return function (object, context) {\n    var aliasMap;\n\n    if (context.selectionSet && context.fragmentMap) {\n      var info = trie.lookupArray([context.selectionSet, context.fragmentMap]);\n      aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n    }\n\n    var keyObject = context.keyObject = computeKeyObject(object, specifier, aliasMap);\n    return context.typename + \":\" + JSON.stringify(keyObject);\n  };\n}\n\nfunction makeAliasMap(selectionSet, fragmentMap) {\n  var map = Object.create(null);\n  var workQueue = new Set([selectionSet]);\n  workQueue.forEach(function (selectionSet) {\n    selectionSet.selections.forEach(function (selection) {\n      if (isField(selection)) {\n        if (selection.alias) {\n          var responseKey = selection.alias.value;\n          var storeKey = selection.name.value;\n\n          if (storeKey !== responseKey) {\n            var aliases = map.aliases || (map.aliases = Object.create(null));\n            aliases[storeKey] = responseKey;\n          }\n        }\n\n        if (selection.selectionSet) {\n          var subsets = map.subsets || (map.subsets = Object.create(null));\n          subsets[selection.name.value] = makeAliasMap(selection.selectionSet, fragmentMap);\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, fragmentMap);\n\n        if (fragment) {\n          workQueue.add(fragment.selectionSet);\n        }\n      }\n    });\n  });\n  return map;\n}\n\nfunction computeKeyObject(response, specifier, aliasMap) {\n  var keyObj = Object.create(null);\n  var prevKey;\n  specifier.forEach(function (s) {\n    if (Array.isArray(s)) {\n      if (typeof prevKey === \"string\") {\n        var subsets = aliasMap && aliasMap.subsets;\n        var subset = subsets && subsets[prevKey];\n        keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n      }\n    } else {\n      var aliases = aliasMap && aliasMap.aliases;\n      var responseName = aliases && aliases[s] || s;\n      process.env.NODE_ENV === \"production\" ? invariant(hasOwn.call(response, responseName), 36) : invariant(hasOwn.call(response, responseName), \"Missing field '\" + responseName + \"' while computing key fields\");\n      keyObj[prevKey = s] = response[responseName];\n    }\n  });\n  return keyObj;\n}\n\nexport { Policies, defaultDataIdFromObject };","map":{"version":3,"sources":["policies.js"],"names":[],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\nimport { KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { getFragmentFromSelection, } from '../../utilities/graphql/fragments';\nimport { isField, getTypenameFromResult, storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, } from '../../utilities/graphql/storeUtils';\nimport { canUseWeakMap } from '../../utilities/common/canUse';\nimport { hasOwn, fieldNameFromStoreName, isFieldValueToBeMerged, storeValueIsStoreObject, } from './helpers';\nfunction argsFromFieldSpecifier(spec) {\n    return spec.args !== void 0 ? spec.args :\n        spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nexport var defaultDataIdFromObject = function (_a, context) {\n    var __typename = _a.__typename, id = _a.id, _id = _a._id;\n    if (typeof __typename === \"string\") {\n        if (context) {\n            context.keyObject =\n                id !== void 0 ? { id: id } :\n                    _id !== void 0 ? { _id: _id } :\n                        void 0;\n        }\n        var idValue = id || _id;\n        if (idValue !== void 0) {\n            return __typename + \":\" + ((typeof idValue === \"number\" ||\n                typeof idValue === \"string\") ? idValue : JSON.stringify(idValue));\n        }\n    }\n};\nvar nullKeyFieldsFn = function () { return void 0; };\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\nvar Policies = (function () {\n    function Policies(config) {\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.storageTrie = new KeyTrie(true);\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n        var typename = selectionSet && fragmentMap\n            ? getTypenameFromResult(object, selectionSet, fragmentMap)\n            : object.__typename;\n        var context = {\n            typename: typename,\n            selectionSet: selectionSet,\n            fragmentMap: fragmentMap,\n        };\n        var id;\n        var policy = this.getTypePolicy(typename, false);\n        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n        while (keyFn) {\n            var specifierOrId = keyFn(object, context);\n            if (Array.isArray(specifierOrId)) {\n                keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n            }\n            else {\n                id = specifierOrId;\n                break;\n            }\n        }\n        id = id && String(id);\n        return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var existing = _this.getTypePolicy(typename, true);\n            var incoming = typePolicies[typename];\n            var keyFields = incoming.keyFields, fields = incoming.fields;\n            if (incoming.queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (incoming.mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (incoming.subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            existing.keyFn =\n                keyFields === false ? nullKeyFieldsFn :\n                    Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n                        typeof keyFields === \"function\" ? keyFields :\n                            existing.keyFn;\n            if (fields) {\n                Object.keys(fields).forEach(function (fieldName) {\n                    var existing = _this.getFieldPolicy(typename, fieldName, true);\n                    var incoming = fields[fieldName];\n                    if (typeof incoming === \"function\") {\n                        existing.read = incoming;\n                    }\n                    else {\n                        var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                        existing.keyFn =\n                            keyArgs === false ? simpleKeyArgsFn :\n                                Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n                                    typeof keyArgs === \"function\" ? keyArgs :\n                                        existing.keyFn;\n                        if (typeof read === \"function\")\n                            existing.read = read;\n                        if (typeof merge === \"function\")\n                            existing.merge = merge;\n                    }\n                    if (existing.read && existing.merge) {\n                        existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                    }\n                });\n            }\n        });\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        if (typename === void 0) { typename = which; }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            invariant(!old || old === which, \"Cannot change root \" + which + \" __typename more than once\");\n            this.rootIdsByTypename[typename] = rootId;\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            var subtypeSet = _this.getSubtypeSet(supertype, true);\n            possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename, createIfMissing) {\n        if (typename) {\n            return this.typePolicies[typename] || (createIfMissing && (this.typePolicies[typename] = Object.create(null)));\n        }\n    };\n    Policies.prototype.getSubtypeSet = function (supertype, createIfMissing) {\n        var policy = this.getTypePolicy(supertype, createIfMissing);\n        if (policy) {\n            return policy.subtypes || (createIfMissing ? policy.subtypes = new Set() : void 0);\n        }\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        var typePolicy = this.getTypePolicy(typename, createIfMissing);\n        if (typePolicy) {\n            var fieldPolicies = typePolicy.fields || (createIfMissing && (typePolicy.fields = Object.create(null)));\n            if (fieldPolicies) {\n                return fieldPolicies[fieldName] || (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n            }\n        }\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes) {\n            var workQueue_1 = [this.getSubtypeSet(supertype, false)];\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var subtypes = workQueue_1[i];\n                if (subtypes) {\n                    if (subtypes.has(typename))\n                        return true;\n                    subtypes.forEach(function (subtype) {\n                        var subsubtypes = _this.getSubtypeSet(subtype, false);\n                        if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {\n                            workQueue_1.push(subsubtypes);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.getStoreFieldName = function (fieldSpec) {\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var context = {\n                typename: typename,\n                fieldName: fieldName,\n                field: fieldSpec.field || null,\n            };\n            var args = argsFromFieldSpecifier(fieldSpec);\n            while (keyFn) {\n                var specifierOrString = keyFn(args, context);\n                if (Array.isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName = fieldSpec.field\n                ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n                : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        return fieldName === fieldNameFromStoreName(storeFieldName)\n            ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (options, context) {\n        var objectOrReference = options.from;\n        if (!objectOrReference)\n            return;\n        var nameOrField = options.field || options.fieldName;\n        if (!nameOrField)\n            return;\n        if (options.typename === void 0) {\n            var typename = context.getFieldValue(objectOrReference, \"__typename\");\n            if (typename)\n                options.typename = typename;\n        }\n        var storeFieldName = this.getStoreFieldName(options);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = context.getFieldValue(objectOrReference, storeFieldName);\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var storage = this.storageTrie.lookup(isReference(objectOrReference)\n                ? objectOrReference.__ref\n                : objectOrReference, storeFieldName);\n            return read(existing, makeFieldFunctionOptions(this, objectOrReference, options, storage, context));\n        }\n        return existing;\n    };\n    Policies.prototype.hasMergeFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.merge);\n    };\n    Policies.prototype.applyMerges = function (existing, incoming, context, storageKeys) {\n        var _this = this;\n        if (isFieldValueToBeMerged(incoming)) {\n            var field = incoming.__field;\n            var fieldName = field.name.value;\n            var merge = this.getFieldPolicy(incoming.__typename, fieldName, false).merge;\n            var storage = storageKeys\n                ? this.storageTrie.lookupArray(storageKeys)\n                : null;\n            incoming = merge(existing, incoming.__value, makeFieldFunctionOptions(this, void 0, { typename: incoming.__typename, fieldName: fieldName,\n                field: field, variables: context.variables }, storage, context));\n        }\n        if (Array.isArray(incoming)) {\n            return incoming.map(function (item) { return _this.applyMerges(void 0, item, context); });\n        }\n        if (storeValueIsStoreObject(incoming)) {\n            var e_1 = existing;\n            var i_1 = incoming;\n            var firstStorageKey_1 = isReference(e_1)\n                ? e_1.__ref\n                : typeof e_1 === \"object\" && e_1;\n            var newFields_1;\n            Object.keys(i_1).forEach(function (storeFieldName) {\n                var incomingValue = i_1[storeFieldName];\n                var appliedValue = _this.applyMerges(context.getFieldValue(e_1, storeFieldName), incomingValue, context, firstStorageKey_1 ? [firstStorageKey_1, storeFieldName] : void 0);\n                if (appliedValue !== incomingValue) {\n                    newFields_1 = newFields_1 || Object.create(null);\n                    newFields_1[storeFieldName] = appliedValue;\n                }\n            });\n            if (newFields_1) {\n                return __assign(__assign({}, i_1), newFields_1);\n            }\n        }\n        return incoming;\n    };\n    return Policies;\n}());\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, storage, context) {\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var variables = fieldSpec.variables || context.variables;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        isReference: isReference,\n        toReference: context.toReference,\n        storage: storage,\n        cache: policies.cache,\n        canRead: context.canRead,\n        readField: function (fieldNameOrOptions, from) {\n            var options = typeof fieldNameOrOptions === \"string\" ? {\n                fieldName: fieldNameOrOptions,\n                from: from,\n            } : __assign({}, fieldNameOrOptions);\n            if (void 0 === options.from) {\n                options.from = objectOrReference;\n            }\n            if (void 0 === options.variables) {\n                options.variables = variables;\n            }\n            return policies.readField(options, context);\n        },\n        mergeObjects: function (existing, incoming) {\n            if (Array.isArray(existing) || Array.isArray(incoming)) {\n                throw new InvariantError(\"Cannot automatically merge arrays\");\n            }\n            if (existing && typeof existing === \"object\" &&\n                incoming && typeof incoming === \"object\") {\n                var eType = context.getFieldValue(existing, \"__typename\");\n                var iType = context.getFieldValue(incoming, \"__typename\");\n                var typesDiffer = eType && iType && eType !== iType;\n                var applied = policies.applyMerges(typesDiffer ? void 0 : existing, incoming, context);\n                if (typesDiffer ||\n                    !storeValueIsStoreObject(existing) ||\n                    !storeValueIsStoreObject(applied)) {\n                    return applied;\n                }\n                return __assign(__assign({}, existing), applied);\n            }\n            return incoming;\n        }\n    };\n}\nfunction keyArgsFnFromSpecifier(specifier) {\n    return function (args, context) {\n        return args ? context.fieldName + \":\" + JSON.stringify(computeKeyObject(args, specifier)) : context.fieldName;\n    };\n}\nfunction keyFieldsFnFromSpecifier(specifier) {\n    var trie = new KeyTrie(canUseWeakMap);\n    return function (object, context) {\n        var aliasMap;\n        if (context.selectionSet && context.fragmentMap) {\n            var info = trie.lookupArray([\n                context.selectionSet,\n                context.fragmentMap,\n            ]);\n            aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n        }\n        var keyObject = context.keyObject =\n            computeKeyObject(object, specifier, aliasMap);\n        return context.typename + \":\" + JSON.stringify(keyObject);\n    };\n}\nfunction makeAliasMap(selectionSet, fragmentMap) {\n    var map = Object.create(null);\n    var workQueue = new Set([selectionSet]);\n    workQueue.forEach(function (selectionSet) {\n        selectionSet.selections.forEach(function (selection) {\n            if (isField(selection)) {\n                if (selection.alias) {\n                    var responseKey = selection.alias.value;\n                    var storeKey = selection.name.value;\n                    if (storeKey !== responseKey) {\n                        var aliases = map.aliases || (map.aliases = Object.create(null));\n                        aliases[storeKey] = responseKey;\n                    }\n                }\n                if (selection.selectionSet) {\n                    var subsets = map.subsets || (map.subsets = Object.create(null));\n                    subsets[selection.name.value] =\n                        makeAliasMap(selection.selectionSet, fragmentMap);\n                }\n            }\n            else {\n                var fragment = getFragmentFromSelection(selection, fragmentMap);\n                if (fragment) {\n                    workQueue.add(fragment.selectionSet);\n                }\n            }\n        });\n    });\n    return map;\n}\nfunction computeKeyObject(response, specifier, aliasMap) {\n    var keyObj = Object.create(null);\n    var prevKey;\n    specifier.forEach(function (s) {\n        if (Array.isArray(s)) {\n            if (typeof prevKey === \"string\") {\n                var subsets = aliasMap && aliasMap.subsets;\n                var subset = subsets && subsets[prevKey];\n                keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n            }\n        }\n        else {\n            var aliases = aliasMap && aliasMap.aliases;\n            var responseName = aliases && aliases[s] || s;\n            invariant(hasOwn.call(response, responseName), \"Missing field '\" + responseName + \"' while computing key fields\");\n            keyObj[prevKey = s] = response[responseName];\n        }\n    });\n    return keyObj;\n}\n//# sourceMappingURL=policies.js.map"]},"metadata":{},"sourceType":"module"}