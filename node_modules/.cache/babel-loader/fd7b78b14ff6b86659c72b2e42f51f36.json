{"ast":null,"code":"import { __assign } from 'tslib';\nimport { InvariantError, invariant } from 'ts-invariant';\nimport { createFragmentMap, getFragmentFromSelection } from '../../utilities/graphql/fragments.js';\nimport { isReference, makeReference, getTypenameFromResult, isField, resultKeyNameFromField } from '../../utilities/graphql/storeUtils.js';\nimport { getOperationDefinition, getDefaultValues, getFragmentDefinitions } from '../../utilities/graphql/getFromAST.js';\nimport { equal } from '@wry/equality';\nimport { shouldInclude, hasDirectives } from '../../utilities/graphql/directives.js';\nimport { cloneDeep } from '../../utilities/common/cloneDeep.js';\nimport { fieldNameFromStoreName, makeProcessedFieldsMerger } from './helpers.js';\n\nvar StoreWriter = function () {\n  function StoreWriter(cache, reader) {\n    this.cache = cache;\n    this.reader = reader;\n  }\n\n  StoreWriter.prototype.writeToStore = function (_a) {\n    var query = _a.query,\n        result = _a.result,\n        dataId = _a.dataId,\n        store = _a.store,\n        variables = _a.variables;\n    var operationDefinition = getOperationDefinition(query);\n    var merger = makeProcessedFieldsMerger();\n    variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n    var objOrRef = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId: dataId,\n      selectionSet: operationDefinition.selectionSet,\n      context: {\n        store: store,\n        written: Object.create(null),\n        merge: function (existing, incoming) {\n          return merger.merge(existing, incoming);\n        },\n        variables: variables,\n        varString: JSON.stringify(variables),\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n        toReference: store.toReference,\n        canRead: store.canRead,\n        getFieldValue: store.getFieldValue\n      }\n    });\n    var ref = isReference(objOrRef) ? objOrRef : dataId && makeReference(dataId) || void 0;\n\n    if (ref) {\n      store.retain(ref.__ref);\n    }\n\n    return ref;\n  };\n\n  StoreWriter.prototype.processSelectionSet = function (_a) {\n    var _this = this;\n\n    var dataId = _a.dataId,\n        result = _a.result,\n        selectionSet = _a.selectionSet,\n        context = _a.context,\n        _b = _a.out,\n        out = _b === void 0 ? {\n      shouldApplyMerges: false\n    } : _b;\n    var policies = this.cache.policies;\n\n    var _c = policies.identify(result, selectionSet, context.fragmentMap),\n        id = _c[0],\n        keyObject = _c[1];\n\n    dataId = dataId || id;\n\n    if (\"string\" === typeof dataId) {\n      var sets = context.written[dataId] || (context.written[dataId] = []);\n      var ref = makeReference(dataId);\n      if (sets.indexOf(selectionSet) >= 0) return ref;\n      sets.push(selectionSet);\n\n      if (this.reader && this.reader.isFresh(result, context.store, ref, selectionSet, context.varString)) {\n        return ref;\n      }\n    }\n\n    var mergedFields = Object.create(null);\n\n    if (keyObject) {\n      mergedFields = context.merge(mergedFields, keyObject);\n    }\n\n    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n\n    if (\"string\" === typeof typename) {\n      mergedFields.__typename = typename;\n    }\n\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a;\n\n      if (!shouldInclude(selection, context.variables)) return;\n\n      if (isField(selection)) {\n        var resultFieldKey = resultKeyNameFromField(selection);\n        var value = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          var storeFieldName = policies.getStoreFieldName({\n            typename: typename,\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables\n          });\n\n          var incomingValue = _this.processFieldValue(value, selection, context, out);\n\n          if (policies.hasMergeFunction(typename, selection.name.value)) {\n            incomingValue = {\n              __field: selection,\n              __typename: typename,\n              __value: incomingValue\n            };\n            out.shouldApplyMerges = true;\n          }\n\n          mergedFields = context.merge(mergedFields, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n        } else if (policies.usingPossibleTypes && !hasDirectives([\"defer\", \"client\"], selection)) {\n          throw process.env.NODE_ENV === \"production\" ? new InvariantError(46) : new InvariantError(\"Missing field '\" + resultFieldKey + \"' in \" + JSON.stringify(result, null, 2).substring(0, 100));\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    if (\"string\" === typeof dataId) {\n      var entityRef_1 = makeReference(dataId);\n\n      if (out.shouldApplyMerges) {\n        mergedFields = policies.applyMerges(entityRef_1, mergedFields, context);\n      }\n\n      if (process.env.NODE_ENV !== \"production\") {\n        Object.keys(mergedFields).forEach(function (storeFieldName) {\n          var fieldName = fieldNameFromStoreName(storeFieldName);\n\n          if (!policies.hasMergeFunction(typename, fieldName)) {\n            warnAboutDataLoss(entityRef_1, mergedFields, storeFieldName, context.store);\n          }\n        });\n      }\n\n      context.store.merge(dataId, mergedFields);\n      return entityRef_1;\n    }\n\n    return mergedFields;\n  };\n\n  StoreWriter.prototype.processFieldValue = function (value, field, context, out) {\n    var _this = this;\n\n    if (!field.selectionSet || value === null) {\n      return process.env.NODE_ENV === 'production' ? value : cloneDeep(value);\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(function (item) {\n        return _this.processFieldValue(item, field, context, out);\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context: context,\n      out: out\n    });\n  };\n\n  return StoreWriter;\n}();\n\nvar warnings = new Set();\n\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n  var getChild = function (objOrRef) {\n    var child = store.getFieldValue(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  var existing = getChild(existingRef);\n  if (!existing) return;\n  var incoming = getChild(incomingObj);\n  if (!incoming) return;\n  if (isReference(existing)) return;\n  if (equal(existing, incoming)) return;\n\n  if (Object.keys(existing).every(function (key) {\n    return store.getFieldValue(incoming, key) !== void 0;\n  })) {\n    return;\n  }\n\n  var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var typeDotName = parentType + \".\" + fieldName;\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n  var childTypenames = [];\n\n  if (!Array.isArray(existing) && !Array.isArray(incoming)) {\n    [existing, incoming].forEach(function (child) {\n      var typename = store.getFieldValue(child, \"__typename\");\n\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  process.env.NODE_ENV === \"production\" || invariant.warn(\"Cache data may be lost when replacing the \" + fieldName + \" field of a \" + parentType + \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \" + (childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have IDs, or \" : \"\") + \"define a custom merge function for the \" + typeDotName + \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \" + JSON.stringify(existing).slice(0, 1000) + \"\\n  incoming: \" + JSON.stringify(incoming).slice(0, 1000) + \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\");\n}\n\nexport { StoreWriter };","map":{"version":3,"sources":["writeToStore.js"],"names":[],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\nimport { createFragmentMap, getFragmentFromSelection, } from '../../utilities/graphql/fragments';\nimport { getDefaultValues, getFragmentDefinitions, getOperationDefinition, } from '../../utilities/graphql/getFromAST';\nimport { getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, } from '../../utilities/graphql/storeUtils';\nimport { shouldInclude, hasDirectives } from '../../utilities/graphql/directives';\nimport { cloneDeep } from '../../utilities/common/cloneDeep';\nimport { makeProcessedFieldsMerger, fieldNameFromStoreName } from './helpers';\n;\nvar StoreWriter = (function () {\n    function StoreWriter(cache, reader) {\n        this.cache = cache;\n        this.reader = reader;\n    }\n    StoreWriter.prototype.writeToStore = function (_a) {\n        var query = _a.query, result = _a.result, dataId = _a.dataId, store = _a.store, variables = _a.variables;\n        var operationDefinition = getOperationDefinition(query);\n        var merger = makeProcessedFieldsMerger();\n        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n        var objOrRef = this.processSelectionSet({\n            result: result || Object.create(null),\n            dataId: dataId,\n            selectionSet: operationDefinition.selectionSet,\n            context: {\n                store: store,\n                written: Object.create(null),\n                merge: function (existing, incoming) {\n                    return merger.merge(existing, incoming);\n                },\n                variables: variables,\n                varString: JSON.stringify(variables),\n                fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n                toReference: store.toReference,\n                canRead: store.canRead,\n                getFieldValue: store.getFieldValue,\n            },\n        });\n        var ref = isReference(objOrRef) ? objOrRef :\n            dataId && makeReference(dataId) || void 0;\n        if (ref) {\n            store.retain(ref.__ref);\n        }\n        return ref;\n    };\n    StoreWriter.prototype.processSelectionSet = function (_a) {\n        var _this = this;\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, _b = _a.out, out = _b === void 0 ? {\n            shouldApplyMerges: false,\n        } : _b;\n        var policies = this.cache.policies;\n        var _c = policies.identify(result, selectionSet, context.fragmentMap), id = _c[0], keyObject = _c[1];\n        dataId = dataId || id;\n        if (\"string\" === typeof dataId) {\n            var sets = context.written[dataId] || (context.written[dataId] = []);\n            var ref = makeReference(dataId);\n            if (sets.indexOf(selectionSet) >= 0)\n                return ref;\n            sets.push(selectionSet);\n            if (this.reader && this.reader.isFresh(result, context.store, ref, selectionSet, context.varString)) {\n                return ref;\n            }\n        }\n        var mergedFields = Object.create(null);\n        if (keyObject) {\n            mergedFields = context.merge(mergedFields, keyObject);\n        }\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n            (dataId && context.store.get(dataId, \"__typename\"));\n        if (\"string\" === typeof typename) {\n            mergedFields.__typename = typename;\n        }\n        var workSet = new Set(selectionSet.selections);\n        workSet.forEach(function (selection) {\n            var _a;\n            if (!shouldInclude(selection, context.variables))\n                return;\n            if (isField(selection)) {\n                var resultFieldKey = resultKeyNameFromField(selection);\n                var value = result[resultFieldKey];\n                if (typeof value !== 'undefined') {\n                    var storeFieldName = policies.getStoreFieldName({\n                        typename: typename,\n                        fieldName: selection.name.value,\n                        field: selection,\n                        variables: context.variables,\n                    });\n                    var incomingValue = _this.processFieldValue(value, selection, context, out);\n                    if (policies.hasMergeFunction(typename, selection.name.value)) {\n                        incomingValue = {\n                            __field: selection,\n                            __typename: typename,\n                            __value: incomingValue,\n                        };\n                        out.shouldApplyMerges = true;\n                    }\n                    mergedFields = context.merge(mergedFields, (_a = {},\n                        _a[storeFieldName] = incomingValue,\n                        _a));\n                }\n                else if (policies.usingPossibleTypes &&\n                    !hasDirectives([\"defer\", \"client\"], selection)) {\n                    throw new InvariantError(\"Missing field '\" + resultFieldKey + \"' in \" + JSON.stringify(result, null, 2).substring(0, 100));\n                }\n            }\n            else {\n                var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n                if (fragment && policies.fragmentMatches(fragment, typename)) {\n                    fragment.selectionSet.selections.forEach(workSet.add, workSet);\n                }\n            }\n        });\n        if (\"string\" === typeof dataId) {\n            var entityRef_1 = makeReference(dataId);\n            if (out.shouldApplyMerges) {\n                mergedFields = policies.applyMerges(entityRef_1, mergedFields, context);\n            }\n            if (process.env.NODE_ENV !== \"production\") {\n                Object.keys(mergedFields).forEach(function (storeFieldName) {\n                    var fieldName = fieldNameFromStoreName(storeFieldName);\n                    if (!policies.hasMergeFunction(typename, fieldName)) {\n                        warnAboutDataLoss(entityRef_1, mergedFields, storeFieldName, context.store);\n                    }\n                });\n            }\n            context.store.merge(dataId, mergedFields);\n            return entityRef_1;\n        }\n        return mergedFields;\n    };\n    StoreWriter.prototype.processFieldValue = function (value, field, context, out) {\n        var _this = this;\n        if (!field.selectionSet || value === null) {\n            return process.env.NODE_ENV === 'production' ? value : cloneDeep(value);\n        }\n        if (Array.isArray(value)) {\n            return value.map(function (item) { return _this.processFieldValue(item, field, context, out); });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context: context,\n            out: out,\n        });\n    };\n    return StoreWriter;\n}());\nexport { StoreWriter };\nvar warnings = new Set();\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    var getChild = function (objOrRef) {\n        var child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    var existing = getChild(existingRef);\n    if (!existing)\n        return;\n    var incoming = getChild(incomingObj);\n    if (!incoming)\n        return;\n    if (isReference(existing))\n        return;\n    if (equal(existing, incoming))\n        return;\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\n        return;\n    }\n    var parentType = store.getFieldValue(existingRef, \"__typename\") ||\n        store.getFieldValue(incomingObj, \"__typename\");\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var typeDotName = parentType + \".\" + fieldName;\n    if (warnings.has(typeDotName))\n        return;\n    warnings.add(typeDotName);\n    var childTypenames = [];\n    if (!Array.isArray(existing) &&\n        !Array.isArray(incoming)) {\n        [existing, incoming].forEach(function (child) {\n            var typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" &&\n                !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    invariant.warn(\"Cache data may be lost when replacing the \" + fieldName + \" field of a \" + parentType + \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \" + (childTypenames.length\n        ? \"either ensure all objects of type \" +\n            childTypenames.join(\" and \") + \" have IDs, or \"\n        : \"\") + \"define a custom merge function for the \" + typeDotName + \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \" + JSON.stringify(existing).slice(0, 1000) + \"\\n  incoming: \" + JSON.stringify(incoming).slice(0, 1000) + \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\");\n}\n//# sourceMappingURL=writeToStore.js.map"]},"metadata":{},"sourceType":"module"}